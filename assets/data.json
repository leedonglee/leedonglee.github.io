[
  {
    "title": "디자인 패턴",
    "questions": [
      {
        "question": "복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 객체를 생성하는 방법(과정)과 객체를 구현(표현) 하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴",
        "answer": "Builder"
      },
      {
        "question": "상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버로딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 갖는 디자인 패턴",
        "answer": "Factory Method"
      },
      {
        "question": "기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴",
        "answer": "Bridge"
      },
      {
        "question": "구제적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴으로 이 패턴을 통해 생성된 클래스에서는 사용자에게 인터페이스(API)를 제공하고, 구체적인 구현은 concrete Product 클래스에서 이루어지는 특징을 갖는 디자인 패턴",
        "answer": "Abstract Factory"
      },
      {
        "question": "전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴",
        "answer": "Singleton"
      },
      {
        "question": "기존 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴으로, 상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태로 사용되는 디자인 패턴",
        "answer": "Adapter"
      },
      {
        "question": "객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 디자인 패턴",
        "answer": "Composite"
      },
      {
        "question": "한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대다 의존성을 가지는 디자인 패턴과 서로 상호작용을 하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인패턴",
        "answer": "Observer"
      },
      {
        "question": "처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴으로, 생성할 객체의 원형을 제공하는 인스턴스에서 생성할 객체들의 타입이 결정되도록 설정하며 객체를 생성할 때 갖추어야 할 기본 형태가 있을 때 사용되는 디자인 패턴",
        "answer": "Prototype"
      },
      {
        "question": "객체 상태를 캡슐화하여 클래스화 함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시 코드의 수정을 최소화할 수 있고, 유지 보수의 편의성도 갖는 디자인 패턴",
        "answer": "State"
      },
      {
        "question": "기존에 구현되어 있는 클래스에 그때그때 필요한 기능을 추가해 나가는 설계 패턴으로 기능 확장이 필요할 때 객체간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 상속의 대안으로 사용하는 디자인 패턴",
        "answer": "Decorator"
      },
      {
        "question": "컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공하는 디자인 패턴",
        "answer": "Iterator"
      },
      {
        "question": "알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화하고 난 뒤, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴으로, 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴",
        "answer": "Strategy"
      },
      {
        "question": "어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴으로 일반적으로 상위 클래스(추상 클래스)에는 추상 메서드를 통해 기능의 골격을 제공하고, 하위 클래스(구체 클래스)의 메서드에는 세부 처리를 구체화하는 방식으로 사용하며 코드 양을 줄이고 유지보수를 용이하게 만드는 특징을 갖는 패턴",
        "answer": "Template Method"
      },
      {
        "question": "클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴으로 undo 기능을 개발할 때 사용하는 패턴",
        "answer": "Memento"
      },
      {
        "question": "복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간, 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴이다. 오류에 대해서 단위별로 확인할 수 있게 하며, 사용자의 측면에서 단순한 인터페이스를 제공하여 접근성을 높일 수 있는 디자인 패턴",
        "answer": "Facade"
      },
      {
        "question": "각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴으로, 객체의 구조는 변경하지 않으면서 기능만 따로 추가하거나 확장할 때 사용하는 디자인 패턴",
        "answer": "Visitor"
      },
      {
        "question": "객체지향 설계에서 객체의 수가 너무 많아지면 서로 통신하느라 복잡해져 객체지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있다. 이를 해결하는 한 가지 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고, 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체지향의 목표를 달성하게 해주는 디자인 패턴",
        "answer": "Mediator"
      },
      {
        "question": "실체 객체에 대한 대리 객체'로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 패턴",
        "answer": "Proxy"
      },
      {
        "question": "실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴으로 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴",
        "answer": "Command"
      },
      {
        "question": "언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 패턴",
        "answer": "Interpreter"
      },
      {
        "question": "정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 시, 기능 처리의 연결 변경이 불가능한데 이를 동적으로 연결되어 있는 경우에 따라서 다르게 처리될 수 있도록 연결한 패턴",
        "answer": "Chain Of Responsibility"
      },
      {
        "question": "다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스화여 공유함으로써 메모리를 절약하고, '클래스의 경량화'를 목적으로 하는 패턴",
        "answer": "Flyweight"
      }
    ]
  },
  {
    "title": "결합도/응집도",
    "questions": [
      {
        "question": "결합도 순서(약 -> 강)",
        "answer": "자료 결합도 -> 스탬프 결합도 -> 제어 결합도 -> 외부 결합도 -> 공통 결합도 -> 내용 결합도"
      },
      {
        "question": "응집도 순서(강 -> 약)",
        "answer": "기능적 응집도 -> 순차적 응집도 -> 통신적 응집도 -> 절차적 응집도 -> 시간적 응집도 -> 논리적 응집도 -> 우연적 응집도"
      },
      {
        "question": "모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호 작용이 일어나는 경우의 결합도",
        "answer": "자료 결합도 (Data Coupling)"
      },
      {
        "question": "모듈 간의 인터페이스로 배열이나 객체, 구조 등이 전달되는 경우의 결합도",
        "answer": "스탬프 결합도 (Stamp Coupling)"
      },
      {
        "question": "어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용하여 통신하는 경우의 결합도",
        "answer": "제어 결합도 (Control Coupling)"
      },
      {
        "question": "어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도",
        "answer": "외부 결합도 (External Coupling)"
      },
      {
        "question": "파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도",
        "answer": "공통 결합도 (Common Coupling)"
      },
      {
        "question": "하나의 모듈이 직접적으로 다른 모듈의 내용을 참조할 때 두 모듈은 내용적으로 결합되어 있는 경우의 결합도",
        "answer": "내용 결합도 (Content Coupling)"
      },
      {
        "question": "모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우의 응집도",
        "answer": "기능적 응집도 (Functional Cohesion)"
      },
      {
        "question": "모듈 내에서 한 활동으로부터 나온 출력 값을 다른 활동이 사용할 경우의 응집도",
        "answer": "순차적 응집도 (Sequential Cohesion)"
      },
      {
        "question": "동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여 있을 경우의 응집도",
        "answer": "통신적 응집도 (Communication Cohesion)"
      },
      {
        "question": "모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우의 응집도",
        "answer": "절차적 응집도 (Procedural Cohesion)"
      },
      {
        "question": "연관된 기능이라기보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우의 응집도",
        "answer": "시간적 응집도 (Temporal Cohesion)"
      },
      {
        "question": "유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우의 응집도",
        "answer": "논리적 응집도 (Logical Cohesion)"
      },
      {
        "question": "서로 다른 상위 모듈에 의해 호출되어 처리상의 연관성이 없는 서로 다른 기능을 수행할 경우의 응집도",
        "answer": "우연적 응집도 (Coincidental Cohesion)"
      }
    ]
  },
  {
    "title": "정보보안",
    "questions": [
      {
        "question": "라이와 메시가 개발한 pes를 개선한 알고리즘",
        "answer": "IDEA"
      },
      {
        "question": "국가 안전 보장국에서 개발한 암호화 알고리즘, 클리퍼 칩이라는 ic칩이 내장되어있음",
        "answer": "Skipjack"
      },
      {
        "question": "임시 키 무결성 프로토콜, 무선랜 보안에 사용된 WEP을 보완한 프토토콜",
        "answer": "TKIP"
      },
      {
        "question": "대칭키 기반 블록 암호화 방식, DES에서 발전",
        "answer": "AES"
      },
      {
        "question": "소인수 분해 방식, 공개키 알고리즘, 비대칭키",
        "answer": "RSA"
      },
      {
        "question": "이산대수 문제를 타원곡선으로 옮겨 기밀성과 효율성을 높인 암호화 알고리즘, 비대칭키",
        "answer": "ECC"
      },
      {
        "question": "패킷의 크기를 허용 범위 이상으로 전송하여 네트워크를 마비 시키는 서비스 거부 공격 방법",
        "answer": "Ping of Death"
      },
      {
        "question": "IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만다는 공격 방법",
        "answer": "스머핑 (Smurfing)"
      },
      {
        "question": "공격자가 가상의 클라이언트로 위장함으로써 3-way-handshake 과정을 의도적으로 중단 시킴으로써 서버가 정상적인 서비스를 수행하지 못하도록 하는 공격 방법",
        "answer": "SYN Flooding"
      },
      {
        "question": "패킷을 재조립할 때 오류로 인한 과부하를 발생시킴으로써 시스템이 다운되도록 하는 공격 방법",
        "answer": "TearDrop"
      },
      {
        "question": "패킷을 전송할 때 송신 IP주소와 수신 IP주소를 모두 공격 대상의 IP주소로 하여 자신에 대한 무한히 응답하게 하는 공격 방법",
        "answer": "LAND Attack"
      },
      {
        "question": "여러곳에서 분산된 공격 지점에서 한곳의 서버에 대해 서비스 공격을 수행하는 것",
        "answer": "DDos"
      },
      {
        "question": "상호 인증 과정을 거친 후 접속해 있는 서버와 클라이언트 사이의 세션 정보를 가로채는 공격 기법",
        "answer": "세션 하이재킹"
      },
      {
        "question": "자신의 물리적 주소를 공격 대상의 것으로 변조하여 데이터 패킷을 가로채거나 방해하는 기법",
        "answer": "ARP 스푸핑"
      },
      {
        "question": "인간 상호작용의 깊은 신뢰를 바탕으로 시스템 침입수단",
        "answer": "사회 공학"
      },
      {
        "question": "활용되지 않고 저장만 되어 있는 대량의 데이터",
        "answer": "다크 데이터"
      },
      {
        "question": "주소를 잘못입력하거나 철자를 빠트리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 것",
        "answer": "타이포스쿼팅"
      },
      {
        "question": "사회 공학의 한 기법으로, 특정 대상을 선정한 후 그 대상에게 일반적인 이메일로 위장한 메일을 지속적으로 발송 후 클릭하도록 유도해 개인 정보 탈취",
        "answer": "스피어 피싱"
      },
      {
        "question": "특정 기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 정보를 수집한 다음 외부로 빼돌리는 형태의 공격",
        "answer": "APT"
      },
      {
        "question": "네트워크의 중간에서 남의 패킷 정보를 도청하는 것",
        "answer": "스니핑"
      },
      {
        "question": "웹 사이트를 사전에 감염시켜, 사이트에 방문 했을때 악성 코드에 감염되게 하는 웹 기반 공격",
        "answer": "워터링 홀"
      },
      {
        "question": "네트워크를 통해 연속적으로 자신을 복제, 시스템의 부하를 높임으로써 시스템을 다운시키는 바이러스의 일종",
        "answer": "웜"
      },
      {
        "question": "컴퓨터 사용자의 키보드 움직임을 감지해 정보를 몰래 빼가는 해킹 공격",
        "answer": "키로거 공격"
      },
      {
        "question": "내부 문서나 파일등을 암호화해서 사용자가 열지 못하게 하는 프로그램",
        "answer": "랜섬웨어"
      },
      {
        "question": "시스템 설계자가 엑세스 편의를 위해 시스템 보안을 제거하여 만들어 놓은 비밀 통로",
        "answer": "백도어"
      },
      {
        "question": "침입 방지 시스템(IDS)에서 미리 입력해둔 공격 패턴이 감지되면 이를 알리는 탐지",
        "answer": "오용 탐지"
      },
      {
        "question": "침입 방지 시스템(IDS)에서 비정상적인 행위나 자원의 사용이 감지되면 이를 알리는 탐지",
        "answer": "이상 탐지"
      },
      {
        "question": "타사이트 인증을 다른 곳에서도 접근 허가",
        "answer": "SSO(Single Sign On)"
      },
      {
        "question": "서버 접근통제 유형인 DAC, MAC, RBAC의 차이",
        "answer": "DAC는 신분/신원에 근거, MAC는 접근 권한에 근거, RBAC는 역할에 근거"
      }
    ]
  },
  {
    "title": "네트워크",
    "questions": [
      {
        "question": "네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능을 제공하는 프로토콜",
        "answer": "IPSec"
      },
      {
        "question": "연결형 통신에서 주로 사용되는 방식으로, 출발지와 목적지의 전송 경로를 미리 연결하여 논리적으로 고정한 후 통신하는 방식",
        "answer": "가상 회선 방식"
      },
      {
        "question": "비연결형 통신에서 주로 사용되는 방식으로, 사전에 접속 절차를 수행하지 않고 헤더에 출발지에서 목적지까지의 경로 지정을 위한 충분한 정보를 붙여서 개별적으로 전달하는 방식",
        "answer": "데이터그램 방식"
      },
      {
        "question": "발생하는 보안 관련 이벤트를 수집, 분석, 관리하여 잠재적인 위협을 탐지하고 대응하는 시스템",
        "answer": "SIEM"
      },
      {
        "question": "공개 키 방식의 암호방식을 사용해 원격지 시스템에 접근하여 암호화된 메시지를 전송할 수 있는 시스템, 키를 통한 인증 방법을 사용하려면 사전에 클라이언트의 공개키를 서버에 등록해야 함",
        "answer": "SSH"
      },
      {
        "question": "IP와 조합하여 통신중에 발생하는 오류의 처리, 전송 경로 변경 등 제어를 담당",
        "answer": "ICMP"
      },
      {
        "question": "멀티캐스트 그룹 유지를 위해 사용됨",
        "answer": "IGMP"
      },
      {
        "question": "IP 주소를 MAC 주소로 변환해주는 프로토콜",
        "answer": "ARP"
      },
      {
        "question": "MAC 주소를 IP 주소로 변환해주는 프로토콜",
        "answer": "RARP"
      },
      {
        "question": "기존 무선 랜 한계 극복, 대규모 디바이스의 네트워크 생성에 최적화, 통신량이 많으면서 비교적 소수 국에서는 경제적",
        "answer": "메시 네트워크"
      },
      {
        "question": "네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 각각의 소프트웨어로 네트워킹을 가상화하여 제어하고 관리하는 네트워크",
        "answer": "SDN"
      },
      {
        "question": "여러 개의 독립된 통신장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술",
        "answer": "피코넷"
      },
      {
        "question": "무선으로 노드간 통신을 하는 자율적인 구조의 네트워크, 재난 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트만을 이용하여 구성한 네트워크",
        "answer": "애드혹 네트워크"
      },
      {
        "question": "고정된 크기의 53 바이트 셀로 데이터를 전송하는 통신 기술",
        "answer": "ATM"
      },
      {
        "question": "WPA2에서 사용되는 암호화 프로토콜로, TKIP를 대체하기 위해 등장, 암호화 방식은 AES 블록 암호화를 기반으로 동작",
        "answer": "CCMP"
      },
      {
        "question": "WPA3에서 사용되는 핸드셰이크 방식으로, 보다 강력한 키 교환을 제공",
        "answer": "SAE"
      }
    ]
  },
  {
    "title": "기타",
    "questions": [
      {
        "question": "수학적 산정 기법에서 LOC에 의한 비용 산정 기법",
        "answer": "COCOMO"
      },
      {
        "question": "소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형",
        "answer": "Putnam 모형"
      },
      {
        "question": "소프트웨어 규모를 측정하는 방법 중 하나로, 사용자가 요구하는 기능의 수와 복잡도를 기반으로 소프트웨어의 크기를 정량화, 알브레히트가 제안한 모형",
        "answer": "기능 점수 모형"
      },
      {
        "question": "Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구",
        "answer": "SLIM"
      },
      {
        "question": "DB 설계 순서 중 트랜잭션 모델링을 하는 단계",
        "answer": "개념적 설계"
      },
      {
        "question": "DB 설계 순서 중 트랜잭션의 인터페이스 설계를 하는 단계",
        "answer": "논리적 설계"
      },
      {
        "question": "DB 설계 순서 중 DB 파일의 저장 구조 및 엑세스 경로를 결정하는 단계",
        "answer": "물리적 설계"
      },
      {
        "question": "데이터 모델을 표시하는 요소 3가지",
        "answer": "구조, 연산, 제약 조건"
      },
      {
        "question": "데이터 모델을 표시할 요소 중 DB를 조작하는 기본 도구를 뜻하는 것",
        "answer": "연산"
      },
      {
        "question": "데이터 모델의 구성 요소 3가지",
        "answer": "개체, 속성, 관계"
      },
      {
        "question": "데이터베이스를 구성하는 가장 작은 논리적 단위",
        "answer": "속성"
      },
      {
        "question": "피터 첸에 의해 제안된 데이터 모델의 가장 대표적인 것",
        "answer": "E-R 모델"
      },
      {
        "question": "수평 분할은 이것을 기준으로 분할, 수직 분할은 이것을 기준으로 분할",
        "answer": "수평: 레코드 / 수직: 속성"
      },
      {
        "question": "트랜잭션의 특성 4가지",
        "answer": "원자성, 독립성, 일관성, 내구성"
      },
      {
        "question": "모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법",
        "answer": "정보 은닉"
      },
      {
        "question": "소프트웨어 상위 설계 3개와 하위 설계 3개",
        "answer": "상위 설계: 구조, DB, 인터페이스 / 하위 설계: 컴포넌트, 자료 구조, 알고리즘"
      },
      {
        "question": "컴포넌트 설계 시 '협약'에 의한 설계를 따를 경우 명세에 포함될 조건 3가지",
        "answer": "선행 조건, 결과 조건, 불변 조건"
      },
      {
        "question": "논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법이고, GOTO나 화살표를 사용하지 않는 차트",
        "answer": "N-S 차트"
      },
      {
        "question": "분산 소프트웨어의 경우 각 분산 환경에 설치된 데몬이 프로그램 테스트에 대한 응답을 대신하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성하는 인터페이스 구현 검증 도구",
        "answer": "STAF"
      },
      {
        "question": "애플리케이션의 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙",
        "answer": "파레토 법칙"
      },
      {
        "question": "동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상",
        "answer": "살충제 패러독스"
      },
      {
        "question": "소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없는 것",
        "answer": "오류-부재의 궤변 (Absence of Errors Fallacy)"
      },
      {
        "question": "제어 흐름도의 순환 복잡도 계산 공식",
        "answer": "화살표의 수 - 노드의 수 + 2"
      },
      {
        "question": "TCP/IP 계층과 애플리케이션 계층 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜",
        "answer": "SSL"
      },
      {
        "question": "방향 그래프의 최대 간선 수 공식 / 무방향 그래프의 최대 간선 수 공식",
        "answer": "n(n-1) / n(n-1)/2"
      }
    ]
  }
]
